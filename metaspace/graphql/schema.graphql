type Person {
  name: String!
  email: String    # null if current user is not allowed to see
}

input PersonInput {
  name: String!
  email: String!
}

type SubmitterSearchResult {
  id: ID!
  name: String!
}

enum Polarity {
  POSITIVE
  NEGATIVE
}

type Analyzer {
  type: String!
  resolvingPower(mz: Float!): Float!
}

enum AnnotationOrderBy {
  ORDER_BY_MZ
  ORDER_BY_MSM
  ORDER_BY_FDR_MSM
  ORDER_BY_DATASET
  ORDER_BY_FORMULA
  ORDER_BY_COLOCALIZATION
}

enum DatasetOrderBy {
  ORDER_BY_DATE
  ORDER_BY_NAME
}

enum SortingOrder {
  ASCENDING,
  DESCENDING
}

enum JobStatus {
  QUEUED,
  ANNOTATING,
  FINISHED,
  FAILED,
}

type FdrCounts {
  dbName: String!
  levels: [Float!]!
  counts: [Float!]!
}

type CompoundInfoEntry {
  database: String!
  url: String
  databaseId: String!
}

type Compound {
  name: String!
  imageURL: String
  information: [CompoundInfoEntry]
  # TODO: InChi/SMILES, ClassyFire results
}

type Adduct {
  adduct: String!
  charge: Int!
}

type Spectrum {
  mzs: [Float!]!
  intensities: [Float!]!
}

type MzImage {
  mz: Float
  url: String
  totalIntensity: Float!
  minIntensity: Float!
  maxIntensity: Float!
}

type MolecularDatabase {
  id: Int!
  name: String!
  version: String!
  default: Boolean!
}

type ColocalizationAlgo {
  id: String!
  name: String!
}

type Annotation {
  id: String!

  dataset: Dataset!
  sumFormula: String!
  adduct: String!
  ion: String!
  database: String!
  mz: Float!
  possibleCompounds: [Compound!]!
  fdrLevel: Float!
  msmScore: Float!
  rhoSpatial: Float
  rhoSpectral: Float
  rhoChaos: Float
  isotopeImages: [MzImage!]!

  peakChartData: String  # JSON

  # Unfortunately Apollo's client-side cache makes it necessary to parameterize colocalizationCoeff so that its values
  # are consistent between requests. Without this, having multiple queries with different 'colocalizedWith' filters
  # will cause the values to interfere, e.g. browsing the Annotations page when using a `colocalizedWith` filter
  # as well as having the "Colocalized With" section open will trigger two queries with different colocalization params
  # in `allAnnotations`, resulting in different values of colocalizationCoeff for the same annotation.
  # If `colocalizationCoeffFilter` is null, this will return null, allowing queries to include this field even if it's not
  # applicable with the current set of filters. Otherwise the values must match the parent `allAnnotations`' filter.
  colocalizationCoeff(colocalizationCoeffFilter: ColocalizationCoeffFilter): Float
}

# [min, max) interval
input NumericRange {
  min: Float!
  max: Float!
}

input AnnotationFilter {
  database: String
  datasetName: String
  mzFilter: NumericRange
  msmScoreFilter: NumericRange
  compoundQuery: String
  fdrLevel: Float
  sumFormula: String
  adduct: String
  colocalizedWith: String         # Should be an ion string (sf+adduct+polarity). Requires DatasetFilter.datasetIds to be set to a specific dataset
  colocalizationSamples: Boolean  # Requires DatasetFilter.datasetIds to be set to a specific dataset
  colocalizationAlgo: String
}

input ColocalizationCoeffFilter {
  colocalizedWith: String!
  colocalizationAlgo: String
  database: String
  fdrLevel: Float!
}

type Query {
  allAnnotations(orderBy: AnnotationOrderBy = ORDER_BY_MSM,
                 sortingOrder: SortingOrder = DESCENDING,
                 offset: Int = 0, limit: Int = 10,
                 filter: AnnotationFilter = {},
                 datasetFilter: DatasetFilter = {},
                 simpleQuery: String): [Annotation]

  countAnnotations(filter: AnnotationFilter = {},
                   datasetFilter: DatasetFilter = {},
                   simpleQuery: String): Int!

  annotation(id: String!): Annotation

  metadataSuggestions(field: String!, query: String!, limit: Int = 10): [String!]!

  submitterSuggestions(query: String!): [SubmitterSearchResult!]!

  molecularDatabases(hideDeprecated: Boolean=true,
    onlyLastVersion: Boolean=true): [MolecularDatabase!]

  adductSuggestions: [Adduct!]!

  colocalizationAlgos: [ColocalizationAlgo!]!
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
