type Group {
  id: ID!
  name: String!
  shortName: String!
  members: [UserGroup!]    # null if current user is not allowed to see
}

input CreateGroupInput {
  name: String!
  shortName: String!
  principalInvestigatorEmail: String!
}

input UpdateGroupInput {
  name: String
  shortName: String
}

# Many-to-many relationship between User and Group - we haven't discussed naming conventions for these.
# I'm used to just joining the two types' names, i.e. "UserGroup" / "GroupUser", but some people prefer
# a name that describes the relationship e.g. "GroupMember" or "UserInGroup".
type UserGroup {
  user: User!
  group: Group!
  role: UserGroupRole!
  numDatasets: Int!
}

enum UserGroupRole {
  INVITED    # User was invited into the group but hasn't confirmed it yet
  PENDING    # User requested to join the group but the PI hasn't confirmed it yet
  MEMBER     # Normal member of the group
  PRINCIPAL_INVESTIGATOR    # Group administrator
}

type Query {
  group(id: ID!): Group
  allGroups(query: String): [Group!]!

  # Not sure if `currentUserRoleInGroup` is the right approach. The requirement is that when a user is viewing a group,
  # the UI changes based on their role within that group. This could also e.g. be done as a `currentUserRole: String`
  # or `currentUserGroup: UserGroup` field on Group.
  currentUserRoleInGroup(groupId: ID!): UserGroupRole
}

type Mutation {
  ## Managing groups
  createGroup(groupDetails: CreateGroupInput!): Group!
  updateGroup(id: ID!, groupDetails: UpdateGroupInput!): Group!
  deleteGroup(groupId: ID!): Boolean!

  ## Managing group users
  leaveGroup(groupId: ID!): Boolean!
  removeUserFromGroup(groupId: ID!, userId: ID!): Boolean!

  ## User requests access
  # `bringDatasets` contains a list of IDs of datasets that the user wants to bring into the group with them
  requestAccessToGroup(groupId: ID!, bringDatasets: [ID!]!): UserGroup!
  acceptRequestToJoinGroup(groupId: ID!, userId: ID!): UserGroup!
  # User can reject request with `leaveGroup`

  ## Group invites user
  inviteUserToGroup(groupId: ID!, email: String!): UserGroup!
  acceptGroupInvitation(groupId: ID!, bringDatasets: [ID!]!): UserGroup!
  # Group can reject user with `removeUserFromGroup`
}
